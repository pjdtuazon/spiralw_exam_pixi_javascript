<!doctype html>
<html>
<head>
  <style>
  canvas {
    padding: 0;
    margin: auto;
    display: block;
   
  }
  </style>
  <meta charset="utf-8">
  <title>Hello World</title>
</head>
  <script src="pixi/pixi.min.js"></script>
  <script src="game/Utils.js"></script>
  <script src="game/Constants.js"></script>
  
<body>
  <canvas id="gamecanvas"></canvas>
  <script type="text/javascript">
    
  //Create a Pixi Application
    const canvas = document.getElementById("gamecanvas");
   
    let screenHeight = Constants.Screen.height;
    let screenWidth = Constants.Screen.width;;

    var GameState = {
        INITIALIZE: 0, //no state, not running and pre-start
        START: 1, // initializing
        RUNNING: 2,
        PAUSED: 3, // pause ticker
        GAME_OVER: 4, // set game over
    };

    var fixedSpawns = [
         {x:100, y:-100},
         {x:200, y:-100},
         {x:480, y:-100},
         {x:100, y:820},
         {x:200, y:820},
         {x:480, y:820},
         {x:580, y:200},
         {x:580, y:600},
         {x:580, y:400},
         {x:-100, y:200},
         {x:-100, y:600},
         {x:-100, y:400},
         ];

    let gameState = GameState.START;

    console.log("Created app and canvas");

    //Add the canvas that Pixi automatically created for you to the HTML document
    let app = new PIXI.Application({
    view: canvas, 
    width: screenWidth, 
    height: screenHeight,
    resolution: window.devicePixelRatio,
    autoDensity: true
    });

    var distanceCur = 0;
    let Application = PIXI.Application,
        TextureLoader = PIXI.loader,
        TextureCache = PIXI.utils.TextureCache;
        Resources = PIXI.loader.resources,
        Sprite = PIXI.Sprite;
    
    app.render(app.stage);

    
    var gameTex = {
        bg: "img/purple.png", 
        play_button: "img/button_test1.png",
        spaceship: "img/playerShip3_blue.png",
        meteor: "img/meteorBrown_big4.png",
        missile: "img/missile.png",
        buttonMove: "img/buttonmove.png",
        buttonRight: "img/buttonright.png",
        buttonLeft: "img/buttonleft.png",
        buttonFire: "img/buttonfire.png",
        bgPopup: "img/popup_bg1.png",
        explosionAnim: "img/explosion.json"
    };

    for (var key in gameTex){
        console.log("key " + gameTex[key]);
        TextureLoader.add(gameTex[key])
    };
    
    TextureLoader.load(setup);

    let explosionTextures = [];    

    let mainScene = new PIXI.Container();
    let gameScene = new PIXI.Container();

    let textStyle = {
        fontFamily: "Futura",
        fontSize: 34,
        fill: "white"
        }
    
    var bg;
    let spaceship;
    var ProjectileType = {
        METEOR: 0,
        MISSILE: 1,
    };
    class Projectile
    {
        constructor(spriteName, position, speed, projectileType)
        {
            this.projectile = new Sprite(Resources[spriteName].texture);
            this.projectile.x = position.x;
            this.projectile.y = position.y;
            
            this.projectile.anchor.set(0.5, 0.5);
            this.projectile.pivot.set(0.5, 0.5);

            this.speed = speed;
            this.type = projectileType;

        }

        setTarget(target)
        {
            this.direction = Utils.normalize(target, this.projectile);
        }
        
        update (delta)
        {
            if(this.type == ProjectileType.METEOR)
            {
                this.moveToTarget();
            }
            else if(this.type == ProjectileType.MISSILE)
            {
                this.moveTowardsRotation();
            }

        }

        moveToTarget()
        {
            this.projectile.x += this.direction.x * this.speed;
            this.projectile.y += this.direction.y * this.speed;
        }

        moveTowardsRotation()
        {
            this.projectile.x += this.speed * Math.cos(this.projectile.rotation);
            this.projectile.y += this.speed * Math.sin(this.projectile.rotation);
        }

        collisionTest(target, maxDistance)
        {
            var deltaX = target.x - this.projectile.x;
            var deltaY = target.y - this.projectile.y;
            var norm = Math.sqrt((deltaX * deltaX) + (deltaY * deltaY));


            return norm < maxDistance;
        }
    }

    class VFXFactory
    {
        static createExplosions(position)
        {
           
            let explosion = new PIXI.extras.AnimatedSprite(explosionTextures);
            explosion.name = name;
            explosion.x = app.screen.width * 0.5;
            explosion.y = app.screen.height * 0.5;
            explosion.anchor.set(0.5);

            explosion.x = position.x;
            explosion.y = position.y;

            explosion.rotation = Math.random() * Math.PI;
           // explosion.scale.set(0.75 + Math.random() * 0.5);
            explosion.animationSpeed = 0.75;
            explosion.loop = false;
           
            return explosion;
        }
    }

    class SpriteFactory
    {
        static createSprite(spriteName, position, width, height)
        {
            let texture = Resources[spriteName].texture;
            var sprite = new Sprite(texture);

            sprite.x = position.x;
            sprite.y = position.y;

            sprite.pivot.set(0.5, 0.5);
            sprite.anchor.set(0.5, 0.5);

            sprite.width = width;
            sprite.height = height;

            return sprite;
        }

        static createSpriteFromAtlas(spriteName, position, rect)
        {
            
            //TODO
            
        }

    }

    class ButtonFactory
    {
        static createButton(spriteName, position)
        {
            let texture = Resources[spriteName].texture;
            var button = new Sprite(texture);

            button.x = position.x;
            button.y = position.y;

            button.pivot.set(0.5, 0.5);
            button.anchor.set(0.5, 0.5);

            button.interactive = true;
            button.buttonMode = true;

            return button;
        }

        static createButtonFromAtlas(spriteName, position, rect)
        {
            let texture = Resources[spriteName].texture;
            var rectangle = new PIXI.Rectangle(rect.x, rect.y, rect.width, rect.height);
            texture.frame = rectangle;
            var button = new Sprite(texture);

            button.x = position.x;
            button.y = position.y;

            button.pivot.set(0.5, 0.5);
            button.anchor.set(0.5, 0.5);

            button.interactive = true;
            button.buttonMode = true;

            return button;
        }

    }

    class Popup
    {
        constructor(sceneName)
        {
            this.name = sceneName;

            
            this.popupContainer = new PIXI.Container();
            this.popupContainer.pivot.set(0.5, 0.5);
            this.popupContainer.x = Constants.ScreenCenter.x;
        }

        initialize()
        {

            this.bg = new Sprite(Resources[gameTex.bgPopup].texture);
            this.bg.pivot.set(0.5, 0.5);
            this.bg.anchor.set(0.5, 0.5);
            this.bg.x = 0;
            this.bg.y = Constants.ScreenCenter.y;
            
            this.popupContainer.addChild(this.bg);

            this.buttonStart = ButtonFactory.createButton(gameTex.buttonRight, {x:0, y:360});

            this.popupContainer.addChild(this.buttonStart);
            // gameState = GameState.RUNNING;
        }

        onButtonUp(buttonDownEventListener)
        {
            this.buttonStart
                .on('pointerup', buttonDownEventListener)
               
        }

       
    }

    class BattleShip 
    {
        velocity = 0;
        turnDirection = 0;

        constructor(spriteName, position, velocity)
        {
            this.ship =  new Sprite(Resources[spriteName].texture);
            this.ship.anchor.set(0.5, 0.5);
            this.ship.pivot.set(0.5, 0.5);
            this.ship.x = position.x;
            this.ship.y = position.y;
            this.velocity = velocity;

            this.ship.rotation = Utils.degToRad(-90);
        }

        turnShip = function(turn)
        {
            this.turnDirection = turn;
        }

        move = function (moveForward) {
            this.moveShip = moveForward;
        }
        
        update (delta)
        {
            if(this.turn != 0)
            {
                this.ship.rotation += Utils.degToRad(Constants.TurnSpeed * this.turnDirection);   
            }

            if(this.moveShip)
            {
               
                this.ship.x += this.velocity * Math.cos(this.ship.rotation);
                this.ship.y += this.velocity * Math.sin(this.ship.rotation);

                if(this.ship.x < 0)
                {
                    this.ship.x = Constants.Screen.width;
                }
                else if (this.ship.x > Constants.Screen.width)
                {
                    this.ship.x = 0;
                }

                if(this.ship.y < 0)
                {
                    this.ship.y = Constants.Screen.height;
                }
                else if (this.ship.y > Constants.Screen.height)
                {
                    this.ship.y = 0;
                }
            }

        }

    }

    class MainScene
    {
        constructor(sceneName)
        {
            this.name = sceneName;

            this.container = new PIXI.Container();

            app.stage.addChild(this.container);

        }

        initialize()
        {
            this.buttonMove = ButtonFactory.createButton(gameTex.buttonMove, {x:240, y:600}, 
            {x:0, y:0, width:64, height:64});
            
            this.container.addChild(this.buttonMove);
        }

        setViewController(uiViewController)
        {

            this.buttonMove
                .on('pointerdown', delta => {  })
                .on('pointerup',  delta => {  } )
                .on('pointerupoutside', () => { } )
                .on('pointerover', () => { } )
                .on('pointerout', () => { } );

        }

        update(delta)
        {
            
        }
    }


    class UIScene
    {
        constructor(sceneName)
        {
            this.name = sceneName;

            this.container = new PIXI.Container();

            app.stage.addChild(this.container);

            
        }

        initialize()
        {
            this.buttonMove = ButtonFactory.createButton(gameTex.buttonMove, {x:240, y:600});

            this.buttonRight = ButtonFactory.createButton(gameTex.buttonRight, {x:340, y:660});

            this.buttonLeft = ButtonFactory.createButton(gameTex.buttonLeft, {x:140, y:660});

            this.buttonFire = ButtonFactory.createButton(gameTex.buttonFire, {x:240, y:680});

            this.container.addChild(this.buttonMove);
            this.container.addChild(this.buttonRight);
            this.container.addChild(this.buttonLeft);
            this.container.addChild(this.buttonFire);
        }

        setShipControls(ship)
        {
            this.buttonRight
                .on('pointerdown', () => { ship.turnShip(1); })
                .on('pointerup',  () => { ship.turnShip(0); } )
                .on('pointerupoutside', () => { ship.turnShip(0);} )
                .on('pointerover', () => { ship.turnShip(0);} )
                .on('pointerout', () => { ship.turnShip(0);} );
            this.buttonMove
                .on('pointerdown', delta => { ship.move(true); })
                .on('pointerup',  delta => { ship.move(false); } )
                .on('pointerupoutside', () => { ship.turnShip(0);} )
                .on('pointerover', () => { ship.turnShip(0);} )
                .on('pointerout', () => { ship.turnShip(0);} );
            this.buttonLeft
                .on('pointerdown', () => { ship.turnShip(-1); })
                .on('pointerup',  () => { ship.turnShip(0); } )
                .on('pointerupoutside', () => { ship.turnShip(0);} )
                .on('pointerover', () => { ship.turnShip(0);} )
                .on('pointerout', () => { ship.turnShip(0);} );
        }

        setInputListener(inputListener)
        {
            this.buttonFire
                .on('pointerdown', () => {  })
                .on('pointerup',  () => { inputListener.spawnMissiles(); } )
                .on('pointerupoutside', () => {} )
                .on('pointerover', () => { } )
                .on('pointerout', () => { } );
        }

        update(delta)
        {
            
        }
    }
    class HealthBar
    {
        constructor(position, maxWidth, height)
        {
            this.healthBar = new PIXI.Container();
            this.healthBar.position.set(position.x, position.y);
            //gameScene.addChild(healthBar);

            //Create the black background rectangle
            let innerBar = new PIXI.Graphics();
            innerBar.beginFill(0x000000);
            innerBar.drawRect(0, 0, maxWidth, height);
            innerBar.endFill();
            this.healthBar.addChild(innerBar);

            //Create the front red rectangle
            let outerBar = new PIXI.Graphics();
            outerBar.beginFill(0xFF3300);
            outerBar.drawRect(0, 0, maxWidth, height);
            outerBar.endFill();
            this.healthBar.addChild(outerBar);

            this.healthBar.outer = outerBar;

            this.maxWidth = maxWidth;
        }

        setProgress(percentProgress)
        {
            if(percentProgress > 1)
            {
                percentProgress = 1;
            }

            if(percentProgress < 0)
            {
                percentProgress = 0;
            }

            this.healthBar.outer.width = this.maxWidth * percentProgress;
        }
    }
    class GameScene
    {
        meteorsPool = [];
        meteorsActive = [];

        missilesPool = [];
        missilesActive = [];

        explosionsPool = [];
        explosionsActive = [];

        maxMeteor = 10;
        maxMissiles = 1;
        maxExplosions = 5;

        PlayerData = 
        {
            hp: 100,
            score:0,
        }

        constructor(sceneName)
        {
            this.name = sceneName;

            this.container = new PIXI.Container();

            app.stage.addChild(this.container);
            
        }

        initialize()
        {
            let bgObj = SpriteFactory.createSprite(gameTex.bg, Constants.ScreenCenter, Constants.Screen.width, Constants.Screen.height);

            this.container.addChild(bgObj);

            this.playerShip  = new BattleShip (gameTex.spaceship, Constants.ScreenCenter, Constants.CruiseSpeed);
            
            this.container.addChild(this.playerShip.ship);

            this.message = new PIXI.Text("Score:", textStyle);
            
            this.message.x = 10;
            this.message.y = 32;

            this.container.addChild(this.message);

            this.timer = 0;

            this.healthBarObj = new HealthBar({x:10, y:10}, 200, 10);
            
            this.container.addChild(this.healthBarObj.healthBar);

        }

        addChild(childObject)
        {
            this.container.addChild(childObject);
        }

        removeChild(childObject)
        {
            this.container.removeChild(childObject);
        }

        onKeyUp(key)
        {
            if (key.keyCode === 87 || key.keyCode === 38) {
                this.playerShip.move(false);
            }

            if (key.keyCode === 70) {
                this.spawnMissiles();
            }

            if ((key.keyCode === 65 || key.keyCode === 37) ||  (key.keyCode === 68 || key.keyCode === 39)) {
                this.playerShip.turnShip(0);
            }
        }

        onKeyDown(key)
        {
            if (key.keyCode === 87 || key.keyCode === 38) {
                console.log("UP");
                this.playerShip.move(true);
            }

            if (key.keyCode === 65 || key.keyCode === 37) {
                console.log("LEFT");
                this.playerShip.turnShip(-1);
            }

            if (key.keyCode === 68 || key.keyCode === 39) 
            {
                this.playerShip.turnShip(1);
            }
        }

        getRandomLocation()
        {
          
            var index = Math. floor((Math.random() * fixedSpawns.length));
            //console.log("Index Spawn " + index);
            
          
            return fixedSpawns[index];
        }

        // Pooling Meteors 
        spawnMeteor()
        {
            if(this.meteorsActive.length < this.maxMeteor && this.meteorsPool.length < 1)
            {
                let maxSpeed =  Math.ceil(Math.random() * Constants.MeteorMaxSpeed);
                var meteor = new Projectile(gameTex.meteor, this.getRandomLocation(), maxSpeed, ProjectileType.METEOR);
                meteor.setTarget(this.playerShip.ship);
                this.container.addChild(meteor.projectile);
                this.meteorsActive.push(meteor);
            }
            else if (this.meteorsPool.length > 0)
            {
                var meteorObj = this.meteorsPool.pop();
                meteorObj.projectile.position = this.getRandomLocation();
                meteorObj.speed = Math.ceil(Math.random() * Constants.MeteorMaxSpeed);
                this.container.addChild(meteorObj.projectile);
                meteorObj.setTarget(this.playerShip.ship);
                this.meteorsActive.push(meteorObj);
            }
        }

        spawnMissiles()
        {
            //console.log("spawnMissiles " + this.missilesActive.length + " " + this.missilesPool.length);
            if(this.missilesActive.length < this.maxMissiles && this.missilesPool.length < 1)
            {
                var missileObj = new Projectile(gameTex.missile, this.playerShip.ship, Constants.MissileSpeed,  ProjectileType.MISSILE);
                this.container.addChild(missileObj.projectile);
                missileObj.projectile.rotation = this.playerShip.ship.rotation;
                this.missilesActive.push(missileObj);
            }
            else if (this.missilesPool.length > 0)
            {
                var missileObj = this.missilesPool.pop();
                missileObj.projectile.position = this.playerShip.ship.position;
                missileObj.projectile.rotation = this.playerShip.ship.rotation;
                this.container.addChild(missileObj.projectile);
                this.missilesActive.push(missileObj);
            }
        }

        despawnExplosions(index)
        {
            var vfxExplosion = this.explosionsActive[index];
            this.container.removeChild(vfxExplosion);
            this.explosionsActive.splice(index, 1);
            
            this.explosionsPool.push(vfxExplosion);
        }

        spawnVFXExplosions(position)
        {
            if(this.explosionsActive.length < this.maxExplosions && this.explosionsPool.length < 1)
            {
                let vfxExplosion = VFXFactory.createExplosions(position);
                this.container.addChild(vfxExplosion);
                this.explosionsActive.push(vfxExplosion);
                vfxExplosion.gotoAndPlay(0);
                
                vfxExplosion.onComplete = () =>
                {
                    this.despawnExplosions(0);
                }
            }
            else if (this.explosionsPool.length > 0)
            {
                let vfxExplosionObj = this.explosionsPool.pop();
                vfxExplosionObj.x = position.x;
                vfxExplosionObj.y = position.y;
                this.container.addChild(vfxExplosionObj);
                this.explosionsActive.push(vfxExplosionObj);
                vfxExplosionObj.gotoAndPlay(0);
            }
        }

        isOutOfBounds(target)
        {
            if(target.x > 900 || target.x < -100 || target.y < -100|| target.y > 900)
            {
                return true;
            }
        }

        updatePlayerDataDisplay()
        {
            this.healthBarObj.setProgress(this.PlayerData.hp / Constants.MaxHP);
            this.message.text = "Score: " + this.PlayerData.score;
        }
        resetValues()
        {
            this.PlayerData.hp = Constants.MaxHP;
            this.PlayerData.score = 0;

            this.playerShip.ship.x = Constants.ScreenCenter.x; 
            this.playerShip.ship.y = Constants.ScreenCenter.y;
            this.playerShip.ship.rotation = Utils.degToRad(-90);
        }
        update(delta)
        {
            switch(gameState)
            {
            case  GameState.START:
                
                this.resetValues();
            this.updatePlayerDataDisplay();
                break;
            case GameState.RUNNING:
                if(this.playerShip != null)
                {
                    this.playerShip.update(delta)
                }
                this.timer += delta;
                this.updateMeteorPositions(delta);
                this.updateMissilePositions(delta);

                this.updatePlayerDataDisplay();

                if(this.PlayerData.hp <= 0)
                {
                    console.log("Game over" + this.PlayerData.hp); 
                    this.setGameOver();

                }
                
                break;
            case  GameState.GAME_OVER:
                break;
            }
        }

        despawnMeteor(index)
        {
            var meteorObj = this.meteorsActive[index];
            this.container.removeChild(meteorObj.projectile);
            this.meteorsActive.splice(index, 1);
            
            this.meteorsPool.push(meteorObj);
        }

        updateMeteorPositions(delta)
        {
            if(this.meteorsActive.length > 0)
            {
                for(var ctr = 0; ctr < this.meteorsActive.length; ctr++)
                {
                    if(this.isOutOfBounds(this.meteorsActive[ctr].projectile))
                    {
                        this.despawnMeteor(ctr);
                        ctr--;
                    }
                    else 
                    {
                        this.meteorsActive[ctr].update(delta);

                        if(this.meteorsActive[ctr].collisionTest(this.playerShip.ship, Constants.MinShipMeteorCollisionDist))
                        {
                            console.log("PlayerShip HP deduction");
                            this.PlayerData.hp -= 5;
                            this.spawnVFXExplosions(this.meteorsActive[ctr].projectile.position);
                            this.despawnMeteor(ctr);
                            ctr--;
                        }
                    }
                }
            }
        }

        despawnMissiles(index)
        {
            var missileObj = this.missilesActive[index];
            this.container.removeChild(missileObj.projectile);
            this.missilesActive.splice(index, 1);
            
            this.missilesPool.push(missileObj);
        }

        updateMissilePositions(delta)
        {
            if(this.missilesActive.length > 0)
            {
                for(var ctr = 0; ctr < this.missilesActive.length; ctr++)
                {
                    if(this.isOutOfBounds(this.missilesActive[ctr].projectile))
                    {
                        
                        this.despawnMissiles(ctr);
                        ctr--;
                    }
                    else 
                    {
                        this.missilesActive[ctr].update(delta);

                        for(var ctr2 = 0; ctr2 < this.meteorsActive.length; ctr2++)
                        {
                            if(this.meteorsActive[ctr2].collisionTest(this.missilesActive[ctr].projectile, Constants.MinMissileMeteorCollisionDist))
                            {
                                console.log("Destroy meteor");
                                this.PlayerData.score += Constants.ScoreIncrement;
                                this.despawnMeteor(ctr2);
                                
                                this.despawnMissiles(ctr);
                                ctr--;
                                
                                break;
                            }
                        }
                    }
                }
            }
        }

        setGameOver()
        {
            gameState = GameState.GAME_OVER;

            gameboardScene.addChild(briefingPopup.popupContainer);
            console.log(">> " + this.missilesActive.length + " .. " + this.meteorsActive.length);
            if(this.missilesActive.length > 0)
            {
                while( this.missilesActive.length > 0)
                {
                    this.despawnMissiles(0);
                }
            }

            if(this.meteorsActive.length > 0)
            {
                while( this.meteorsActive.length > 0 )
                {
                    this.despawnMeteor(0);
                }
            }
        }
      
    }

    let gameboardScene = new GameScene("GameboardScene");
    let uiScene = new UIScene("UIScene");
    let briefingPopup = new Popup("BriefingPopup");
    // setup scenes
    function setup()
    {
        
        for (var i = 0; i < 16; i++) {
            const texture = PIXI.Texture.from("explosion"+ i +".png");
            explosionTextures.push(texture);
        }

        gameboardScene.initialize();
        uiScene.initialize();
        briefingPopup.initialize();
        briefingPopup.onButtonUp(onButtonUp);
        
        gameboardScene.addChild(briefingPopup.popupContainer);

        uiScene.setShipControls(gameboardScene.playerShip);
        uiScene.setInputListener(gameboardScene);

        app.ticker.add(delta => {gameboardScene.update(delta);});
        app.ticker.add(delta => {uiScene.update(delta);});

        gameState = GameState.START;

        setTimeout(triggerMeteorFire, Constants.SpawnMeteorWaitTime);

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        
    }
    function onKeyDown(key)
    {
        gameboardScene.onKeyDown(key);
    }
    function onKeyUp(key)
    {
        gameboardScene.onKeyUp(key);
    }
    function triggerMeteorFire()
    {
        if(gameState == GameState.RUNNING)
        {
            setTimeout(triggerMeteorFire,  Constants.SpawnMeteorWaitTime);

            gameboardScene.spawnMeteor();
        }
    }

    function setupGameScene()
    {

    }

    function onButtonDown() {
        this.isdown = true;
    // this.texture = textureButtonDown;
        this.alpha = 1;
        console.log("onButtonDown"); 
    }

    function onButtonUp() {
        this.isdown = false;
        if (this.isOver) {
            //this.texture = textureButtonOver;
        } else {
            //this.texture = textureButton;
        }
        console.log("onButtonUp" + gameState); 
        
        if(gameState == GameState.START)
        {
            gameState = GameState.RUNNING;
            gameboardScene.removeChild(briefingPopup.popupContainer);
            setTimeout(triggerMeteorFire, 1500);
        
        }
        else if (gameState == GameState.GAME_OVER)
        {
            gameboardScene.resetValues();
            gameState = GameState.RUNNING;
            gameboardScene.removeChild(briefingPopup.popupContainer);
            setTimeout(triggerMeteorFire, 1500);
        }
    }

    function onButtonOver() {
        this.isOver = true;
        if (this.isdown) {
            return;
        }
        console.log("onButtonOver"); //this.texture = textureButtonOver;
    }

    function onButtonOut() {
        this.isOver = false;
        if (this.isdown) {
            return;
        }
        console.log("onButtonOut"); //this.texture = textureButton;
    }

    document.body.appendChild(app.view);

  </script>
  
</body>
</html>