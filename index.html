<!doctype html>
<html>
<head>
  <style>
  canvas {
    padding: 0;
    margin: auto;
    display: block;
   
  }
  </style>
  <meta charset="utf-8">
  <title>Hello World</title>
</head>
  <script src="pixi/pixi.min.js"></script>
  <script src="game/Utils.js"></script>
  
<body>
  <canvas id="gamecanvas"></canvas>
  <script type="text/javascript">
    
  //Create a Pixi Application
    const canvas = document.getElementById("gamecanvas");

    
    const CruiseSpeed=1.5;
    const TurnSpeed=5;
    const MissileSpeed=7;
    const MeteorMaxSpeed=4;
    const MinShipMeteorCollisionDist=200;

    let screenHeight = 720;
    let screenWidth = 480;

    var GameState = {
        INITIALIZE: 0, //no state, not running and pre-start
        START: 1, // initializing
        RUNNING: 2,
        PAUSED: 3, // pause ticker
        GAME_OVER: 4, // set game over
    };

    var fixedSpawns = [
         {x:100, y:100},
         {x:100, y:400},
         {x:200, y:100},
         {x:300, y:500},
         {x:150, y:20},
         ];

    let gameState = GameState.START;

    console.log("Created app and canvas");

    //Add the canvas that Pixi automatically created for you to the HTML document
    let app = new PIXI.Application({
    view: canvas, 
    width: screenWidth, 
    height: screenHeight,
    resolution: window.devicePixelRatio,
    autoDensity: true
    });

    var distanceCur = 0;
    let Application = PIXI.Application,
        TextureLoader = PIXI.loader,
        TextureCache = PIXI.utils.TextureCache;
        Resources = PIXI.loader.resources,
        Sprite = PIXI.Sprite;
    
    app.render(app.stage);

    
    var gameTex = {
        bg: "img/purple.png", 
        play_button: "img/button_test1.png",
        spaceship: "img/playerShip3_blue.png",
        meteor: "img/meteorBrown_big4.png",
        missile: "img/missile.png",
        buttonMove: "img/buttonmove.png",
        buttonRight: "img/buttonright.png",
        buttonLeft: "img/buttonleft.png",
        buttonFire: "img/buttonfire.png",
        bgPopup: "img/popup_bg1.png",
        explosionAnim: "img/explosion.json"
    };

    for (var key in gameTex){
        console.log("key " + gameTex[key]);
        TextureLoader.add(gameTex[key])
    };
    
    TextureLoader.load(setup);

    let explosionTextures = [];    

    let mainScene = new PIXI.Container();
    let gameScene = new PIXI.Container();
    
    var bg;
    let spaceship;
    var ProjectileType = {
        METEOR: 0,
        MISSILE: 1,
    };
    class Projectile
    {
        constructor(spriteName, position, speed, projectileType)
        {
            this.projectile = new Sprite(Resources[spriteName].texture);
            this.projectile.x = position.x;
            this.projectile.y = position.y;
            
            this.projectile.anchor.set(0.5, 0.5);
            this.projectile.pivot.set(0.5, 0.5);

            this.speed = speed;
            this.type = projectileType;

        }

        setTarget(target)
        {
            this.direction = Utils.normalize(target, this.projectile);
        }
        
        update (delta)
        {
            if(this.type == ProjectileType.METEOR)
            {
                this.moveToTarget();
            }
            else if(this.type == ProjectileType.MISSILE)
            {
                this.moveTowardsRotation();
            }

        }

        moveToTarget()
        {
            this.projectile.x += this.direction.x * this.speed;
            this.projectile.y += this.direction.y * this.speed;
        }

        moveTowardsRotation()
        {
            this.projectile.x += this.speed * Math.cos(this.projectile.rotation);
            this.projectile.y += this.speed * Math.sin(this.projectile.rotation);
        }

        collisionTest(target, maxDistance)
        {
            var deltaX = target.x - this.projectile.x;
            var deltaY = target.y - this.projectile.y;
            var norm = Math.sqrt((deltaX * deltaX) + (deltaY * deltaY));


            return norm < maxDistance;
        }
    }

    class VFXFactory
    {
        static createExplosions(position)
        {
           
            let explosion = new PIXI.extras.AnimatedSprite(explosionTextures);
            explosion.name = name;
            explosion.x = app.screen.width * 0.5;
            explosion.y = app.screen.height * 0.5;
            explosion.anchor.set(0.5);

            explosion.x = position.x;
            explosion.y = position.y;

            explosion.rotation = Math.random() * Math.PI;
           // explosion.scale.set(0.75 + Math.random() * 0.5);
            explosion.animationSpeed = 0.75;
            explosion.loop = false;
           
            return explosion;
        }
    }

    class SpriteFactory
    {
        static createSprite(spriteName, position, width, height)
        {
            let texture = Resources[spriteName].texture;
            var sprite = new Sprite(texture);

            sprite.x = position.x;
            sprite.y = position.y;

            sprite.pivot.set(0.5, 0.5);
            sprite.anchor.set(0.5, 0.5);

            sprite.width = width;
            sprite.height = height;

            return sprite;
        }

        static createSpriteFromAtlas(spriteName, position, rect)
        {
            
            //TODO
            
        }

    }

    class ButtonFactory
    {
        static createButton(spriteName, position)
        {
            let texture = Resources[spriteName].texture;
            var button = new Sprite(texture);

            button.x = position.x;
            button.y = position.y;

            button.pivot.set(0.5, 0.5);
            button.anchor.set(0.5, 0.5);

            button.interactive = true;
            button.buttonMode = true;

            return button;
        }

        static createButtonFromAtlas(spriteName, position, rect)
        {
            let texture = Resources[spriteName].texture;
            var rectangle = new PIXI.Rectangle(rect.x, rect.y, rect.width, rect.height);
            texture.frame = rectangle;
            var button = new Sprite(texture);

            button.x = position.x;
            button.y = position.y;

            button.pivot.set(0.5, 0.5);
            button.anchor.set(0.5, 0.5);

            button.interactive = true;
            button.buttonMode = true;

            return button;
        }

    }

    class Popup
    {
        constructor(sceneName)
        {
            this.name = sceneName;

            this.container = new PIXI.Container();
            
            app.stage.addChild(this.container);

            let bgTexture = Resources[gameTex.bgPopup].texture;
            var popupContainer = new PIXI.Container();
                       
            var bg = new Sprite(bgTexture);
            bg.pivot.set(0.5, 0.5);
            bg.anchor.set(0.5, 0.5);
            bg.x = 240;
            bg.y = 360;

            popupContainer.addChild(bg);

            this.buttonStart = ButtonFactory.createButton(gameTex.buttonRight, {x:240, y:360});
            popupContainer.addChild(this.buttonStart);

            this.container.addChild(popupContainer);
        }

       
    }

    class BattleShip 
    {
        velocity = 0;
        turnDirection = 0;

        constructor(spriteName, position, velocity)
        {
            this.ship =  new Sprite(Resources[spriteName].texture);
            this.ship.anchor.set(0.5, 0.5);
            this.ship.pivot.set(0.5, 0.5);
            this.ship.x = position.x;
            this.ship.y = position.y;
            this.velocity = velocity;

            this.ship.rotation = Utils.degToRad(-90);
        }

        turnShip = function(turn)
        {
            this.turnDirection = turn;
        }

        move = function (moveForward) {
            this.moveShip = moveForward;
        }
        
        update (delta)
        {
            if(this.turn != 0)
            {
                this.ship.rotation += Utils.degToRad(TurnSpeed * this.turnDirection);   
            }

            if(this.moveShip)
            {
                this.ship.x += this.velocity * Math.cos(this.ship.rotation);
                this.ship.y += this.velocity * Math.sin(this.ship.rotation);
            }

        }

    }

    class MainScene
    {
        constructor(sceneName)
        {
            this.name = sceneName;

            this.container = new PIXI.Container();

            app.stage.addChild(this.container);

        }

        initialize()
        {
            this.buttonMove = ButtonFactory.createButton(gameTex.buttonMove, {x:240, y:600}, 
            {x:0, y:0, width:64, height:64});
            
            this.container.addChild(this.buttonMove);
        }

        setViewController(uiViewController)
        {

            this.buttonMove
                .on('pointerdown', delta => {  })
                .on('pointerup',  delta => {  } )
                .on('pointerupoutside', () => { } )
                .on('pointerover', () => { } )
                .on('pointerout', () => { } );

        }

        update(delta)
        {
            
        }
    }


    class UIScene
    {
        constructor(sceneName)
        {
            this.name = sceneName;

            this.container = new PIXI.Container();

            app.stage.addChild(this.container);

            
        }

        initialize()
        {
            this.buttonMove = ButtonFactory.createButton(gameTex.buttonMove, {x:240, y:600});

            this.buttonRight = ButtonFactory.createButton(gameTex.buttonRight, {x:340, y:660});

            this.buttonLeft = ButtonFactory.createButton(gameTex.buttonLeft, {x:140, y:660});

            this.buttonFire = ButtonFactory.createButton(gameTex.buttonFire, {x:240, y:690});

            this.container.addChild(this.buttonMove);
            this.container.addChild(this.buttonRight);
            this.container.addChild(this.buttonLeft);
            this.container.addChild(this.buttonFire);
        }

        setShipControls(ship)
        {
            this.buttonRight
                .on('pointerdown', () => { ship.turnShip(1); })
                .on('pointerup',  () => { ship.turnShip(0); } )
                .on('pointerupoutside', () => { ship.turnShip(0);} )
                .on('pointerover', () => { ship.turnShip(0);} )
                .on('pointerout', () => { ship.turnShip(0);} );
            this.buttonMove
                .on('pointerdown', delta => { ship.move(true); })
                .on('pointerup',  delta => { ship.move(false); } )
                .on('pointerupoutside', () => { ship.turnShip(0);} )
                .on('pointerover', () => { ship.turnShip(0);} )
                .on('pointerout', () => { ship.turnShip(0);} );
            this.buttonLeft
                .on('pointerdown', () => { ship.turnShip(-1); })
                .on('pointerup',  () => { ship.turnShip(0); } )
                .on('pointerupoutside', () => { ship.turnShip(0);} )
                .on('pointerover', () => { ship.turnShip(0);} )
                .on('pointerout', () => { ship.turnShip(0);} );
        }

        setInputListener(inputListener)
        {
            this.buttonFire
                .on('pointerdown', () => {  })
                .on('pointerup',  () => { inputListener.spawnMissiles(); } )
                .on('pointerupoutside', () => {} )
                .on('pointerover', () => { } )
                .on('pointerout', () => { } );
        }

        update(delta)
        {
            
        }
    }

    class GameScene
    {
        meteorsPool = [];
        meteorsActive = [];

        missilesPool = [];
        missilesActive = [];

        explosionsPool = [];
        explosionsActive = [];

        maxMeteor = 10;
        maxMissiles = 1;
        maxExplosions = 5;

        constructor(sceneName)
        {
            this.name = sceneName;

            this.container = new PIXI.Container();

            app.stage.addChild(this.container);

        }

        initialize()
        {
            let bgObj = SpriteFactory.createSprite(gameTex.bg, {x:240, y:360}, 480, 720);

            this.container.addChild(bgObj);

            this.playerShip  = new BattleShip (gameTex.spaceship, {x:240, y:360}, 2);
            
            this.container.addChild(this.playerShip.ship);

                
        }

        onKeyUp(key)
        {
            if (key.keyCode === 87 || key.keyCode === 38) {
            // If the W key or the Up arrow is pressed, move the player up.
                console.log("UP");
                this.playerShip.move(false);
            }

            // S Key is 83
            // Down arrow is 40
            if (key.keyCode === 70) {
                // If the S key or the Down arrow is pressed, move the player down.
                console.log("fire");
                this.spawnMissiles();
            }

            // A Key is 65
            // Left arrow is 37
            // D Key is 68
            // Right arrow is 39
            if ((key.keyCode === 65 || key.keyCode === 37) ||  (key.keyCode === 68 || key.keyCode === 39)) {
                // If the A key or the Left arrow is pressed, move the player to the left.
                console.log("LEFT");
                this.playerShip.turnShip(0);
            }
        }

        onKeyDown(key)
        {
            if (key.keyCode === 87 || key.keyCode === 38) {
            // If the W key or the Up arrow is pressed, move the player up.
                console.log("UP");
                this.playerShip.move(true);
            }

            // S Key is 83
            // Down arrow is 40
            if (key.keyCode === 83 || key.keyCode === 40) {
                // If the S key or the Down arrow is pressed, move the player down.
                console.log("DOWN");
            }

            // A Key is 65
            // Left arrow is 37
            if (key.keyCode === 65 || key.keyCode === 37) {
                // If the A key or the Left arrow is pressed, move the player to the left.
                console.log("LEFT");
                this.playerShip.turnShip(-1);
            }

            // D Key is 68
            // Right arrow is 39
            if (key.keyCode === 68 || key.keyCode === 39) 
            {
                console.log("RIGHT");
                this.playerShip.turnShip(1);
            
            }
        }
        getRandomLocation()
        {
            // var xRandomValue, yRandomValue;

            // xRandomValue = (Math.random() * 10) + 200 * (Math.random() < 0.5 ? -1 : 1);
            // yRandomValue = (Math.random() * 10) + 400 * (Math.random() < 0.5 ? -1 : 1);

            var index = Math. floor((Math.random() * 5));
            //console.log("Index Spawn " + index);
            
            //return {x:xRandomValue, y:yRandomValue};
            return fixedSpawns[index];
        }

        // Pooling Meteors 
        spawnMeteor()
        {
            //console.log("spawnMeteor " + this.meteorsActive.length + " " + this.meteorsPool.length);
            if(this.meteorsActive.length < this.maxMeteor && this.meteorsPool.length < 1)
            {
                let maxSpeed =  Math.ceil(Math.random() * MeteorMaxSpeed);
                console.log("maxSpeed " + maxSpeed + "" );
                var meteor = new Projectile(gameTex.meteor, this.getRandomLocation(), maxSpeed, ProjectileType.METEOR);
                
                meteor.setTarget(this.playerShip.ship);
                this.container.addChild(meteor.projectile);

                this.meteorsActive.push(meteor);
            }
            else if (this.meteorsPool.length > 0)
            {
                var meteorObj = this.meteorsPool.pop();
                meteorObj.projectile.position = this.getRandomLocation();
                meteorObj.speed = Math.ceil(Math.random() * MeteorMaxSpeed);
                this.container.addChild(meteorObj.projectile);
                meteorObj.setTarget(this.playerShip.ship);
                this.meteorsActive.push(meteorObj);
            }
        }

        spawnMissiles()
        {
            //console.log("spawnMissiles " + this.missilesActive.length + " " + this.missilesPool.length);
            if(this.missilesActive.length < this.maxMissiles && this.missilesPool.length < 1)
            {
                var missileObj = new Projectile(gameTex.missile, this.playerShip.ship, MissileSpeed,  ProjectileType.MISSILE);
                this.container.addChild(missileObj.projectile);
                missileObj.projectile.rotation = this.playerShip.ship.rotation;
                this.missilesActive.push(missileObj);
            }
            else if (this.missilesPool.length > 0)
            {
                var missileObj = this.missilesPool.pop();
                missileObj.projectile.position = this.playerShip.ship.position;
                missileObj.projectile.rotation = this.playerShip.ship.rotation;
                this.container.addChild(missileObj.projectile);
                this.missilesActive.push(missileObj);
            }
        }

        despawnExplosions(index)
        {
            var vfxExplosion = this.explosionsActive[index];
            this.container.removeChild(vfxExplosion);
            this.explosionsActive.splice(index, 1);
            
            this.explosionsPool.push(vfxExplosion);
        }

        spawnVFXExplosions(position)
        {
            if(this.explosionsActive.length < this.maxExplosions && this.explosionsPool.length < 1)
            {
                let vfxExplosion = VFXFactory.createExplosions(position);
                this.container.addChild(vfxExplosion);
                this.explosionsActive.push(vfxExplosion);
                vfxExplosion.gotoAndPlay(0);
                
                vfxExplosion.onComplete = () =>
                {
                    this.despawnExplosions(0);
                }
            }
            else if (this.explosionsPool.length > 0)
            {
                let vfxExplosionObj = this.explosionsPool.pop();
                vfxExplosionObj.x = position.x;
                vfxExplosionObj.y = position.y;
                this.container.addChild(vfxExplosionObj);
                this.explosionsActive.push(vfxExplosionObj);
                vfxExplosionObj.gotoAndPlay(0);
            }
        }

        isOutOfBounds(target)
        {
            if(target.x > 900 || target.x < -100 || target.y < -100|| target.y > 900)
            {
                return true;
            }
        }

        update(delta)
        {
            switch(gameState)
            {
            case  GameState.START:
                break;
            case GameState.RUNNING:
                if(this.playerShip != null)
                {
                    this.playerShip.update(delta)
                }

                this.updateMeteorPositions(delta);
                this.updateMissilePositions(delta);
                break;
            }
        }

        despawnMeteor(index)
        {
            var meteorObj = this.meteorsActive[index];
            this.container.removeChild(meteorObj.projectile);
            this.meteorsActive.splice(index, 1);
            
            this.meteorsPool.push(meteorObj);
        }

        updateMeteorPositions(delta)
        {
            if(this.meteorsActive.length > 0)
            {
                for(var ctr = 0; ctr < this.meteorsActive.length; ctr++)
                {
                    if(this.isOutOfBounds(this.meteorsActive[ctr].projectile))
                    {
                        this.despawnMeteor(ctr);
                        ctr--;
                    }
                    else 
                    {
                        this.meteorsActive[ctr].update(delta);

                        if(this.meteorsActive[ctr].collisionTest(this.playerShip.ship, 32))
                        {
                            console.log("PlayerShip HP deduction");
                            this.spawnVFXExplosions(this.meteorsActive[ctr].projectile.position);
                            this.despawnMeteor(ctr);
                            ctr--;
                        }
                    }
                }
            }
        }

        despawnMissiles(index)
        {
            var missileObj = this.missilesActive[index];
            this.container.removeChild(missileObj.projectile);
            this.missilesActive.splice(index, 1);
            
            this.missilesPool.push(missileObj);
        }

        updateMissilePositions(delta)
        {
            if(this.missilesActive.length > 0)
            {
                for(var ctr = 0; ctr < this.missilesActive.length; ctr++)
                {
                    if(this.isOutOfBounds(this.missilesActive[ctr].projectile))
                    {
                        
                        this.despawnMissiles(ctr);
                        ctr--;
                    }
                    else 
                    {
                        this.missilesActive[ctr].update(delta);

                        for(var ctr2 = 0; ctr2 < this.meteorsActive.length; ctr2++)
                        {
                            if(this.meteorsActive[ctr2].collisionTest(this.missilesActive[ctr].projectile, 32))
                            {
                                console.log("Destroy meteor");
                                this.despawnMeteor(ctr2);
                                
                                this.despawnMissiles(ctr);
                                ctr--;
                                
                                break;
                            }
                        }
                    }
                }
            }
        }
    }

    let gameboardScene = new GameScene("GameboardScene");
    let uiScene = new UIScene("UIScene");
    let briefingPopup = new Popup("BriefingPopup");
    // setup scenes
    function setup()
    {
        
        for (var i = 0; i < 16; i++) {
            const texture = PIXI.Texture.from("explosion"+ i +".png");
            explosionTextures.push(texture);
        }

        bg = new Sprite(Resources[gameTex.play_button].texture);
        bg.pivot.set(0.5, 0.5);
        bg.anchor.set(0.5, 0.5);
        bg.scale.set(5, 5);

        let playButton = new Sprite(Resources[gameTex.play_button].texture);
        playButton.pivot.set(0.5, 0.5);
        playButton.anchor.set(0.5, 0.5);
        
        playButton.x = 240;
        playButton.y = 360;

        playButton.interactive = true;
        playButton.buttonMode = true;
        playButton.on('pointerdown', onButtonDown)
        .on('pointerup', onButtonUp)
        .on('pointerupoutside', onButtonUp)
        .on('pointerover', onButtonOver)
        .on('pointerout', onButtonOut);


        gameboardScene.initialize();
        uiScene.initialize();

        //gameboardScene.container.addChild(briefingPopup.container);

        uiScene.setShipControls(gameboardScene.playerShip);
        uiScene.setInputListener(gameboardScene);

        document.addEventListener('keydown', onKeyDown);
            
        document.addEventListener('keyup', onKeyUp);

        app.ticker.add(delta => {gameboardScene.update(delta);});
        app.ticker.add(delta => {uiScene.update(delta);});

        gameState = GameState.RUNNING;

        setTimeout(triggerMeteorFire, 1500);

    }
    function onKeyDown(key)
    {
        gameboardScene.onKeyDown(key);
    }3
    function onKeyUp(key)
    {
        gameboardScene.onKeyUp(key);
    }
    function triggerMeteorFire()
    {
        setTimeout(triggerMeteorFire, 1500);

        gameboardScene.spawnMeteor();
    }

    function setupGameScene()
    {

    }

    

    
    function onButtonDown() {
        this.isdown = true;
    // this.texture = textureButtonDown;
        this.alpha = 1;
        console.log("onButtonDown"); 
    }

    function onButtonUp() {
        this.isdown = false;
        if (this.isOver) {
            //this.texture = textureButtonOver;
        } else {
            //this.texture = textureButton;
        }
        console.log("onButtonUp"); 
    }

    function onButtonOver() {
        this.isOver = true;
        if (this.isdown) {
            return;
        }
        console.log("onButtonOver"); //this.texture = textureButtonOver;
    }

    function onButtonOut() {
        this.isOver = false;
        if (this.isdown) {
            return;
        }
        console.log("onButtonOut"); //this.texture = textureButton;
    }

    document.body.appendChild(app.view);

  </script>
  
</body>
</html>